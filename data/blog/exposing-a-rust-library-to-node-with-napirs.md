---
title: Exposing a Rust Library to Node with Napi-rs
date: 2023-04-28T22:45:08.080Z
tags: ['rust', 'node', 'typescript']
draft: false
summary: Short guide/exploration on making native node addons with rust
images: []
layout: PostLayout
---

<TOCInline toc={props.toc} asDisclosure />

I unapologetically shill for Rust any chance I get. I annoy my coworkers any chance I get to say how things would be better if we just used Rust. It's basically a meme at this point so no one actually listens to me (rightfully so).

So to finally stop the meme I figured I would start researching ways we could actually incorporate Rust into our systems. Ideally we would make a new service in Rust, but we aren't big on microservices (yet). So the best path would be to call rust directly from node.
Since Node is written in C++ it has ways to call out to native code via [addons](https://nodejs.org/api/addons.html), the library [napi-rs](https://napi.rs/) helps with the boilerplate of exposing rust code as a node addon.

Napi-rs along with generating the node addon will also generate typescript type definitions and has a nice CLI to more easily make addons for all popular systems/architectures.

## Setting up napi

I'm going to experiment with napi in the codebase from the [build a db in rust series](/blog/build-a-db/part01), branch with all the code [here](https://github.com/JRMurr/SQLJr/tree/napi-bindings/crates/sql_jr_node).

Most of the following is taken form the [napi getting started docs](https://napi.rs/docs/introduction/getting-started)

You first need to install the napi CLI, which can be done with your favorite node package manager of choice.
While I could use npm/yarn/pnpm, I like use nix flakes for any CLI tool, so I added the following to my project's flake file

```nix:flake.nix
  buildInputs = with pkgs; [
     napi-rs-cli
  ]'
```

The CLI will generate a rust crate with the right build scripts to build the node addon, the needed node boilerplate to load the addon with type definitions, and some GitHub actions to build and publish the npm packages.

Run the CLI with

```shell
napi new
```

you will get an interactive prompt to give a package name and folder path (useful if you use cargo workspaces). The docs recommend prefixing the package name with a [npm scope](https://docs.npmjs.com/creating-and-publishing-scoped-public-packages/) since napi will publish multiple packages for different architectures.

The generated rust will look like

```rust:src/lib.rs
#[napi]
pub fn sum(a: i32, b: i32) -> i32 {
  a + b
}
```

A generated test file which uses the node addon looks like

```javascript:__test__/index.spec.mjs
import test from 'ava'

import { sum } from '../index.js'

test('sum from native', (t) => {
  t.is(sum(1, 2), 3)
})
```

The other main piece is the `index.js` file at the package root which has all the logic for loading the right addon for each architecture.

you can then run the following to build the addon, generate TS types, and run tests

```shell
npm install # replace with your node package manager of choice
npm run build # builds the rust code into a node addon + add typescript definitons
npm run test # runs the sample js test file using the node addon
```

After the build step you should see and `index.d.ts` file that looks like

```typescript
/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export function sum(a: number, b: number): number;
```

## Using napi

To explore more of napi, let's write a rust function that does something slightly more sophisticated with my SQL_JR db.

```rust:src/lib.rs
#[napi]
pub fn basic_query() -> Vec<Vec<String>> {
    let mut exec = sql_jr_execution::Execution::new();
    exec.parse_and_run(
        "
      CREATE TABLE foo (
        col1 int,
        col2 string
      );
    ",
    )
    .expect("create works..");

    exec.parse_and_run(
        "
        INSERT INTO foo
        VALUES
            1, 'aString';
      ",
    )
    .expect("insert 1 works..");

    exec.parse_and_run(
        "
        INSERT INTO foo
        VALUES
            4, 'aDiffString with spaces';
    ",
    )
    .expect("insert 2 works..");

    let res = exec
        .parse_and_run(
            "
        SELECT
          col1,
          col2
        FROM
            foo;
        ",
        )
        .expect("select works");

    match res {
        ExecResponse::Select(table_iter) => {
            let columns: Vec<String> = table_iter
                .columns
                .iter()
                .map(|col| col.name.to_string())
                .collect();

            let rows: Vec<Vec<_>> = table_iter
                .map(|row| {
                    columns
                        .iter()
                        .map(move |col| row.get(col).to_string())
                        .collect()
                })
                .collect();

            rows
        }
        _ => unreachable!(),
    }
}
```

The above code is very jank rust, but it will get the job done for explore for now.
After running the build we can use it the test file like so

```javascript:__test__/index.spec.mjs
import test from "ava";

import { basicQuery } from "../index.js";

test("basic test", (t) => {
  t.deepEqual(basicQuery(), [
    ["1", "aString"],
    ["4", "aDiffString with spaces"],
  ]);
});
```

One thing you'll notice is the casing of `basic_query` in rust was changed to `basicQuery` in JS.

### Exposing Classes

While the above works its obviously very restrictive and crappy rust, so let's expose a wrapper around `sql_jr_execution::Execution`, so the node side can run arbitrary queries + track state.

Like we did with functions you can add the `#[napi]` macro above structs to expose them as a JS class.
While we could add that macro in the `sql_jr_execution` crate on the `Execution` struct itself I think it will be better to have a napi crate + explicit wrapper structs to keep the API of the node addon more stable. Also, as you will come to see there are some limitations on the exposed code that would be nice to not litter the rest of the code base with.

So let's make a `NodeExec` struct like so

```rust:src/lib.rs
#[napi(js_name = "Execution")]
pub struct NodeExec {
    execution: Execution,
}

#[napi]
impl NodeExec {
    #[napi(constructor)]
    pub fn new() -> Self {
        Self {
            execution: Execution::new(),
        }
    }
}
```

This will expose a JS class called `Execution` with a constructor corresponding to the `new` function.

Let's add a class method that will run a query return an array of records when it was a select query.

```rust
/// A List of rows returned by the query.
/// Each row is a map of col => data as string
type QueryRes = Vec<HashMap<String, String>>;

#[napi]
impl NodeExec {
  #[napi(ts_return_type = "Array<Record<string,string>>")]
  pub fn query(&mut self, query: String) -> napi::Result<QueryRes> {
      use napi::{Error, Status};
      let res = self
          .execution
          .parse_and_run(&query)
          // Probably a good idea to impl From<SqlError<_> for napi::Error in sql_jr_execution
          // gated behind a napi feature flag
          .map_err(|e| Error::new(Status::GenericFailure, format!("{}", e)))?;

      Ok(match res {
          ExecResponse::Select(table_iter) => {
              let columns: Vec<String> = table_iter
                  .columns
                  .iter()
                  .map(|col| col.name.to_string())
                  .collect();

              table_iter
                  .map(|row| {
                      columns
                          .iter()
                          .map(move |col| (col.clone(), row.get(col).to_string()))
                          .collect()
                  })
                  .collect()
          }
          _ => Vec::new(),
      })
  }
}
```

First we need to manually set `ts_return_type = "Array<Record<string,string>>"` since we used a type alias in the function signatures. This is due to some limitations into how [proc macros in rust work](https://github.com/napi-rs/napi-rs/issues/1019#issuecomment-1009116165).

Second we needed to convert the returned Error from `parse_and_run` into a `napi::Error` with `.map_err(|e| Error::new(Status::GenericFailure, format!("{}", e)))`. This is not the best conversion since it would just stringify the execution error but it's not the end of the world.

The generated typescript looks like

```typescript
/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export function basicQuery(): Array<Array<string>>;
export type NodeExec = Execution;
export class Execution {
  constructor();
  query(query: string): Array<Record<string, string>>;
}
```

To use this we can add the following test.

```javascript:__test__/index.spec.mjs
import test from "ava";

import { Execution } from '../index.js';

test('exec struct', (t) => {
    const exec = new Execution();

    t.deepEqual(
        exec.query(`
        CREATE TABLE foo (
          col1 int,
          col2 string
        );
      `),
        []
    );

    t.deepEqual(
        exec.query(`
          INSERT INTO foo
          VALUES
              1, 'aString';
        `),
        []
    );

    t.deepEqual(
        exec.query(`
          INSERT INTO foo
          VALUES
              4, 'aDiffString with spaces';
        `),
        []
    );

    t.deepEqual(
        exec.query(`
          SELECT
            col1,
            col2
          FROM
              foo;
        `),
        [
            {
                col1: '1',
                col2: 'aString',
            },
            {
                col1: '4',
                col2: 'aDiffString with spaces',
            },
        ]
    );
});

test('parse error', (t) => {
    const exec = new Execution();

    t.throws(() => exec.query(`sad`), { code: 'GenericFailure', message: 'Parse Error' });
});
```

In the success case we get an array of records, in the failure case a JS error is thrown.

## napi limitations

- Some “rustisms” can’t transfer to JS/TS
  - The borrow checker cannot work across language boundaries, which could lead to unsound behavior with async code.
  - JS uses exceptions and not Result so any napi function returning a result will throw an error in node. Similar issue for option which just becomes `undefined | T`
    - Would be cool to add a feature in napi to make rust results be exposed as https://github.com/supermacro/neverthrow result or a similar lib
- Need to convert errors into a custom napi error
  - Not the end of the world but more boilerplate
- No node stream support (hopefully coming in napi-rs v3)
- Overhead when passing complex types between node and rust
  - https://github.com/napi-rs/napi-rs/issues/1493
  - Some workarounds like using typed-arrays which are zero copy but requires more work on the node side to serialize/deserialize properly
- Generator support is expermintal and no async generator support

## Wrap up

Overall napi is very useable and with my limited use of cross language FFI tools, it has had the nicest user experience.
While it has limitations/some issues overall nothing major is in your way from exposing very useable and performant code.
